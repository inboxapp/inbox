#!/usr/bin/env python
"""
Populate the AccountTransaction table with existing `account` Transaction
record data. Note the AccountTransaction.{created_at, updated_at} are
populated as well.

IMPORTANT
---------
This script can be run in two modes: run/ re-run.

The run mode populates *ALL* shards from the *beginning* of the Transaction table
*without* checking for duplicates -- this is so eliminate the need for an extra
.first_or_none() query before creating every new AccountTransaction record.
(Since duplicates can be efficiently removed from the AccountTransaction table
if needed, this is not dangerous).

The re-run mode is to be used if running against a shard fails. It requires a
shard key and from_txn_id. It populates the single shard with transactions >
from_txn_id.

"""
import gevent
import click

from inbox.ignition import engine_manager
from inbox.models.session import session_scope_by_shard_id
from inbox.models import Transaction, AccountTransaction
from inbox.sqlalchemy_ext.util import safer_yield_per


@click.command()
@click.option('--run-type', required=True, type=click.Choice(['run', 'rerun']))
@click.option('--key', default=None, type=int)
@click.option('--from-txn-id', default=None, type=int)
def main(run_type, key, from_txn_id):
    if run_type == 'rerun':
        if key is None or from_txn_id is None:
            print 'Missing required args: key, from-txn-id'
            return
        return rerun(key, from_txn_id)
    return run()


def run():
    greenlets = []
    for key in engine_manager.engines:
        print 'Running for shard: {}'.format(key)
        g = gevent.spawn(populate, key)
        greenlets.append(g)
    gevent.joinall(greenlets)


def rerun(key, from_txn_id):
    print 'Re-running for shard: {} from txn_id: {}'.format(key, from_txn_id)
    g = gevent.spawn(populate, key, from_txn_id)
    gevent.joinall([g])


def populate(key, from_txn_id=None):
    max_populated_txn_id = None
    try:
        with session_scope_by_shard_id(key) as db_session:
            transactions = db_session.query(Transaction).filter(
                Transaction.object_type == 'account')

            if from_txn_id:
                transactions = transactions.filter(Transaction.id > from_txn_id)

            for t in safer_yield_per(transactions, Transaction.id, 0, 1000):
                account_txn = AccountTransaction(
                    namespace_id=t.namespace_id,
                    object_type='account',
                    record_id=t.record_id,
                    object_public_id=t.object_public_id,
                    command=t.command)
                # Update these too.
                account_txn.created_at = t.created_at
                account_txn.updated_at = t.updated_at
                db_session.add(account_txn)
                db_session.commit()

                max_populated_txn_id = t.id
    except Exception as e:
        print 'Failed for shard: {}. max_populated_txn_id: {}. error: {}'.\
            format(key, max_populated_txn_id, str(e))
        return

    print 'Succeeded for shard: {}'.format(key)


if __name__ == "__main__":
    main()
